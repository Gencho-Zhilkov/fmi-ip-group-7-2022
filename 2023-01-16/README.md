## [Feedback за упражненията](https://forms.gle/u1CRaXrRZ8qqLgdp9)

## [Рекурсия](https://en.wikipedia.org/wiki/Recursion):

1. Идея: целта е да сведем решението на дадена задача до комбинация от по-прости (масив с по-малък брой елементи, число по-близо до нула, ...) случаи на **същата** - или _[подобна](https://en.wikipedia.org/wiki/Mutual_recursion)_ - задача.

2. Еквивалентност между рекурсия и итерация (for/while): **Всеки** итеративен алгоритъм може да бъде реформулиран като рекурсивен. **Всеки** рекурсивен алгоритъм може да се пренапише като итерация (евентуално с помощта на допълнителни структури от данни). На едно по-дълбоко ниво, двете представляват два различни **подхода**/начина на мислене към решаването на един алгоритмичен проблем. Хубаво е да можете да превключвате от единия към другия и обратно.

_RQ._ Причината рекурсията и итерацията да са еквивалентни идва от еквивалентността между _универсалната машина на Туринг_ (итерация) и _λ-смятането/λ-calculus_ (рекурсия).

3. Структура: **всяка** рекурсивна функия се състой от:

а). Едно или повече _"дъна"_/гранични/базови случай: това за най-простите случай, чието решение ни е известно от само себе си
- Когато работим с числа, това обикновено са стойностите `0` и `1`
- Когато работим с масиви: празният масив или този с един елемент

b). Общ случай: целта тук е да се приближим към някое от дъната (напр. `n` -> `n - 1`)

4. Паралели между _рекурсия_ и _математическa индукция_: подобно на рекурсията, в математическата индукция доказваме едно твърдение като

a). Един, или няколко, базови случая: това са точно дъната на рекурсията!

b). Индуктивна стъпка: където, приемайки, че твърдението е вярно за _"предходните"_ случаи - напр `n-1` - доказваме, че то ще е вярно и за настоящия, т.е `n`.


### Примери

1. **n!**

- Итеративно решение:
```cpp
int factorial(int n) {
   int res = 1;
   for (int i = 0; i < n; i ++) {
      res *= i;
   }
   return res;
}
```

- Рекурсивно решение:
```cpp
int factorial(int n) {
   if (n <= 1) {
      return 1;
   } else {
      return n * factorial(n - 1);
   }
}
```

- [Опашкова рекурсия](https://www.geeksforgeeks.org/tail-recursion/):
```cpp
int factorial_helper(int n, int res) {
   if (n <= 1) {
      return res;
   } else {
      return factorial_helper(n - 1, n * res);
   }
}

int factorial(int n) {
   return factorial_helper(n, 1);
}
```

**N.B.** Опашковата рекурсия **не** заделя стакови рамки и е на практика неразличима от итерацията като производителност (performance) и консумация на памет (memory footprint).
Съвременните компилатори буквално генерират същия машинен код за двете!

2. Сбор на елемените на масив:

- Рекурсивно решение:
```cpp
int sum(int arr[], size_t len) {
   if (len == 0) {
      return 0;
   } else {
      return sum(arr, n - 1) + arr[n-1];
   }
}
```

- Опашкова рекурсия:
```cpp
int sum_helper(int arr[], size_t len, int acc) {
   if (len == 0) {
      return acc;
   } else {
      return sum_helper(&arr[1], len - 1, acc + arr[0]);
   }
}

int sum(int arr[], size_t len) {
   return sum_helper(arr, len);
}
```

3. `atoi` (приемаме че символният низ съдържа само цифри)
```cpp
int toDigit(char c) {
   assert ('0' <= c && c <= '9');
   return c - '0';
}

int atoi_helper(const char *num, int acc) {
   if (*num == '\0') {
      return acc; // базов случай: обработили сме целия низ.
   } else {
      return atoi_helper(num + 1, 10 * acc + toDigit(*num));
   }
}

int atoi(const char *num) {
   return atoi_helper(num, 0);
}
```

_RQ._ Понякога опашковата рекурсия ни дава най-простото и елегантно рекурсивно решение!

## Задачи:

1. Редица на фибоначи: да се напише **рекурсивна** функция, която приема цяло число `n` и връща `n`-тия член на редицата на фибоначи.

2. Средно аритметично: дефинирайте **рекурсивна**, която приема масив от (реални) числа връща средното им аритметично.

3. Провекра за просто число: дефинирайте **рекурсивна** функция isPrime, която приема цяло число `n` и връща дали то е просто.

4. Дефинирайте **рекурсивна** функция, която приема символен низ и премахва от него всички символи, които не са (малки или главни) латински букви.

5. [Quicksort](https://en.wikipedia.org/wiki/Quicksort): имплементирайте алгоритъма за сортиране [quicksort](https://www.geeksforgeeks.org/quick-sort/)

6. [Knapsack](https://en.wikipedia.org/wiki/Knapsack_problem): нека имаме множество предмети представено като целочислен списък `weights`, съдържащ теглото на всеки от предметите, както и контейнер (_раница_), която може да побере максимално тегло `wMax`. Отпечатайте предметите, които трябва да сложим в контейнера, за да го запълним максимално без същевременно да превишим максималното му тегло.

7. [Sudoku](https://en.wikipedia.org/wiki/Sudoku): Напишете функция, която приема символен низ (с дължина 81), съответстващ на частично решение на играта судоку и го решава. Функцията да хвърля грешка, ако даденият пъзел не може да бъде решен.

Пример:
- in:  "4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"
- out: "417369825632158947958724316825437169791586432346912758289643571573291684164875293"

Допълнителни примери можете да намерите [тук](https://norvig.com/top95.txt), а решенията им [тук](https://norvig.com/top95solutions.html)
